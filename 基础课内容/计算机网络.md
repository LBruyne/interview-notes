## 计算机网络

#### TCP和UDP

- TCP(Transmission Control Protocol）和UDP（User Datagram Protocol）协议属于传输层协议，他们之间的区别包括：
  - 是否连接：TCP是面向连接的，UDP是无连接的，TCP的发送发要确认接收方是否收到数据段（3次握手协议）
  - 传输可靠性：TCP是可靠的，UDP是不可靠的；TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复，它通过为每个数据报提供一个序号来完成此恢复，为确保正确收到数据，TCP要求目标计算机成功收到数据时发回一个确认（即ACK），如果在某个时限内未收到相应的ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复，但是接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。UDP协议不能保证数据准确无误的到达目的地，并不是说UDP就完全无法知道是否发生了错误，一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。
  - TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式
  - TCP是面向字节流的，UDP是面向报文的（流模式和数据报模式）
  - TCP拥有拥塞控制机制，UDP没有拥塞控制，适合媒体通信
  - TCP要求系统资源较多，UDP较少
  - TCP首部开销（20个字节）比UDP的首部开销（8个字节）要大，TCP传送数据段的时候要给段标号，UDP协议不用



#### TCP可靠性的来源

- 数据包校验：目的是检测数据在传输过程中的任何变化，若校验包出错，则丢弃报文不给出响应，这时TCP发送数据端超时后会重发数据。
- 超时重发：当TCP发出一个段之后，启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- 对失序数据包重排序：TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层。
- 丢弃重复数据：将丢弃重复数据。
- 应答机制：当TCP收到来自另一端的数据，它将发送一个确认。
- 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。



#### 网络访问一个网站，从输入输入网址到响应，浏览器和服务器都有哪些活动？

- 总的来说有以下几个步骤：

  DNS 解析:将域名解析成 IP 地址

  TCP 连接：TCP 三次握手

  发送 HTTP 请求

  服务器处理请求并返回 HTTP 报文

  浏览器解析渲染页面

  断开连接：TCP 四次挥手



#### TCP三次握手四次挥手

- **三次握手**

  <img src="imgs/20180717202520531.png" alt="img" style="zoom: 67%;" />

  第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入**SYN_SENT**状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入**SYN_RECV**状态；

  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态，完成三次握手。

- **四次挥手**

  <img src="imgs/20180717204202563.png" alt="img" style="zoom: 67%;" />

  1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
  2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
  3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
  4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
  5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
  6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些

- 为什么建立连接是三次握手，而断开连接是四次挥手

  因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

- 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

  虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

- 为什么不能用两次握手进行连接？

  3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

  现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。